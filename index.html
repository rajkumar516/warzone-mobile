<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>War Zone Mobile - Final</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: Impact, sans-serif; user-select: none; touch-action: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* CROSSHAIR */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: #0f0; border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 4px #0f0;
            z-index: 20;
        }

        /* SCOPE */
        #scope-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; z-index: 15;
            background-image: 
                linear-gradient(to bottom, transparent 49.9%, black 49.9%, black 50.1%, transparent 50.1%),
                linear-gradient(to right, transparent 49.9%, black 49.9%, black 50.1%, transparent 50.1%),
                radial-gradient(circle closest-side, transparent 25%, black 25.5%, black 27%, transparent 27.5%),
                radial-gradient(circle closest-side, transparent 45%, black 95%);
            background-size: 100% 100%;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* MINIMAP */
        #minimap {
            position: absolute; top: 20px; right: 20px;
            width: 150px; height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 5px;
            overflow: hidden;
            z-index: 50;
        }
        .map-dot { position: absolute; width: 8px; height: 8px; border-radius: 50%; transform: translate(-50%, -50%); }
        #player-arrow { 
            position: absolute; top: 50%; left: 50%; z-index: 2; 
            width: 0; height: 0; 
            border-left: 6px solid transparent; border-right: 6px solid transparent;
            border-bottom: 12px solid #00ff00;
            transform-origin: center center; transform: translate(-50%, -50%);
        }
        .enemy-dot { background: red; z-index: 1; border: 1px solid white; }

        /* SOUND TOGGLE */
        #sound-toggle {
            position: absolute; top: 20px; left: 20px;
            width: 40px; height: 40px;
            background: rgba(0,0,0,0.5); border: 2px solid white; border-radius: 5px;
            color: white; font-size: 24px; cursor: pointer; pointer-events: auto;
            display: flex; justify-content: center; align-items: center; z-index: 100;
        }

        /* HUD */
        #hud-health { position: absolute; bottom: 30px; left: 30px; color: #33ff33; font-size: 40px; text-shadow: 2px 2px 0 #000; }
        #hud-kills { position: absolute; top: 20px; left: 80px; color: #ff3333; font-size: 40px; text-shadow: 2px 2px 0 #000; }
        #hud-ammo { position: absolute; bottom: 30px; right: 30px; font-size: 50px; color: yellow; text-shadow: 2px 2px 0 #000; }
        #reload-msg { position: absolute; top: 70%; left: 50%; transform: translate(-50%, -50%); color: red; font-size: 24px; display: none; }
        .center-msg { position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); color: #0f0; font-size: 30px; display: none; text-shadow: 2px 2px 0 #000; }

        /* FULLSCREEN SCREENS */
        .fullscreen-msg { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            text-align: center; display: none; z-index: 999; width: 100%;
            background: rgba(0,0,0,0.8); padding: 50px; pointer-events: auto;
        }
        .msg-text { 
            color: #FFD700; font-size: 60px; text-shadow: 0 0 10px orange; margin-bottom: 20px;
            animation: bounce 1s infinite alternate;
        }
        @keyframes bounce { from { transform: scale(1); } to { transform: scale(1.1); } }

        /* --- MOBILE CONTROLS --- */
        .mobile-control { pointer-events: auto; position: absolute; opacity: 0.7; z-index: 50; display: none; }
        
        #joystick-zone { bottom: 50px; left: 50px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid white; }
        #joystick-stick { position: relative; top: 50%; left: 50%; width: 40px; height: 40px; background: white; border-radius: 50%; transform: translate(-50%, -50%); }
        
        #btn-shoot { bottom: 60px; right: 40px; width: 80px; height: 80px; background: red; border-radius: 50%; border: 3px solid white; }
        #btn-scope { bottom: 160px; right: 50px; width: 60px; height: 60px; background: rgba(0,0,0,0.5); border-radius: 50%; border: 2px solid white; color: white; display: flex; justify-content: center; align-items: center; font-size: 12px; }
        
        /* NEW BUTTONS FOR MOBILE */
        #btn-reload { bottom: 60px; right: 140px; width: 50px; height: 50px; background: orange; border-radius: 50%; border: 2px solid white; color: black; font-weight: bold; display: flex; justify-content: center; align-items: center; font-size: 20px; }
        #btn-heal { bottom: 130px; right: 140px; width: 50px; height: 50px; background: green; border-radius: 50%; border: 2px solid white; color: white; font-weight: bold; display: flex; justify-content: center; align-items: center; font-size: 20px; }

        @media (max-width: 900px) { .mobile-control { display: flex !important; } }

        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 100;
        }
        button {
            padding: 20px 50px; font-size: 30px; background: #ff9900; color: #000;
            border: none; cursor: pointer; font-weight: bold; border-radius: 10px;
            box-shadow: 0 0 20px #ff9900; margin-top: 20px; pointer-events: auto;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="scope-overlay"></div>
        <div id="sound-toggle">ðŸ”Š</div>
        <div id="minimap"><div id="player-arrow"></div></div>

        <div id="hud-health">HP: 100</div>
        <div id="hud-kills">KILLS: 0 / 15</div>
        <div id="hud-ammo">150</div>
        <div id="reload-msg">RELOADING...</div>
        <div id="heal-msg" class="center-msg">HEALING...</div>

        <div id="victory-screen" class="fullscreen-msg">
            <div class="msg-text">WINNER WINNER<br>DAAL BATI DINNER!</div>
            <button class="btn-restart">PLAY AGAIN</button>
        </div>

        <div id="death-screen" class="fullscreen-msg">
            <div class="msg-text" style="color:red">YOU DIED</div>
            <button class="btn-restart">TRY AGAIN</button>
        </div>

        <div id="joystick-zone" class="mobile-control"><div id="joystick-stick"></div></div>
        <div id="btn-shoot" class="mobile-control"></div>
        <div id="btn-scope" class="mobile-control">SCOPE</div>
        <div id="btn-reload" class="mobile-control">R</div>
        <div id="btn-heal" class="mobile-control">H</div>
    </div>
    
    <div id="menu">
        <h1 style="color:white; font-size:50px; margin:0;">WAR ZONE</h1>
        <h2 style="color:orange; margin:0;">FINAL EDITION</h2>
        <button id="start-btn">DEPLOY</button>
        <div style="color:yellow; margin-top:10px" id="loader">Loading Environment...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        
        // NO TGA LOADER NEEDED - USING PNG

        const CONFIG = {
            speed: 50,
            camDist: 5.0,
            camHeight: 3.5,
            gunScale: 0.008,
            gunOffset: { x: 0.35, y: 1.4, z: 0.6 },
            gunRot: { x: 0, y: -Math.PI/2, z: 0 },
            totalEnemies: 15,
            fireRate: 0.08,  
            mapScale: 4.0,
            damage: 10,       
            damageCooldown: 1.0,
            attackRange: 40 
        };

        let scene, camera, renderer, controls;
        let player, gun, mixer;
        let muzzleFlash;
        let enemies = [];
        let kills = 0, ammo = 150, health = 100;
        let gameActive = false;
        let enemyTemplate = null; 
        
        let listener, bgm, vicMusic, sfxShoot, sfxHit;
        let isMuted = false;
        
        let move = { fwd: 0, right: 0 };
        let isFiring = false, isScoped = false, isReloading = false;
        let lastShot = 0, lastDamageTime = 0;
        const clock = new THREE.Clock();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            const amb = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 1.5);
            dir.position.set(100, 200, 100);
            dir.castShadow = true;
            scene.add(dir);

            createNature();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            listener = new THREE.AudioListener();
            camera.add(listener);
            const loader = new THREE.AudioLoader();
            bgm = new THREE.Audio(listener);
            loader.load('bg.mp3', (b) => { bgm.setBuffer(b); bgm.setLoop(true); bgm.setVolume(0.3); });
            vicMusic = new THREE.Audio(listener);
            loader.load('victory.mp3', (b) => { vicMusic.setBuffer(b); vicMusic.setVolume(1.0); });
            sfxShoot = new THREE.Audio(listener);
            loader.load('shoot.mp3', (b) => { sfxShoot.setBuffer(b); sfxShoot.setVolume(0.4); });
            sfxHit = new THREE.Audio(listener);
            loader.load('hit.mp3', (b) => { sfxHit.setBuffer(b); sfxHit.setVolume(0.6); });

            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            player = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), new THREE.MeshBasicMaterial({visible:false}));
            scene.add(player);

            loadAssets();
            setupInputs();

            const soundBtn = document.getElementById('sound-toggle');
            soundBtn.addEventListener('click', () => {
                isMuted = !isMuted;
                listener.setMasterVolume(isMuted ? 0 : 1);
                soundBtn.innerText = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
            });

            document.querySelectorAll('.btn-restart').forEach(btn => {
                btn.addEventListener('click', resetGame);
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createNature() {
            const floorGeo = new THREE.PlaneGeometry(1000, 1000);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x33aa33, roughness: 1 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI/2;
            scene.add(floor);

            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.5, 3);
            const trunkMat = new THREE.MeshStandardMaterial({color: 0x8B4513});
            const leaveGeo = new THREE.ConeGeometry(3, 6, 8);
            const leaveMat = new THREE.MeshStandardMaterial({color: 0x006400});

            for(let i=0; i<60; i++) {
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 1.5;
                const leaves = new THREE.Mesh(leaveGeo, leaveMat);
                leaves.position.y = 5;
                tree.add(trunk);
                tree.add(leaves);
                const x = (Math.random()-0.5)*400;
                const z = (Math.random()-0.5)*400;
                if(Math.abs(x) > 30 || Math.abs(z) > 30) {
                    tree.position.set(x, 0, z);
                    const scale = 1 + Math.random();
                    tree.scale.set(scale, scale, scale);
                    scene.add(tree);
                }
            }
        }

        function loadAssets() {
            const fbx = new FBXLoader();
            const texLoader = new THREE.TextureLoader(); // USING STANDARD TEXTURE LOADER
            const txt = document.getElementById('loader');

            fbx.load('player.fbx', (obj) => {
                txt.innerText = "Loading Gun...";
                obj.scale.set(0.012, 0.012, 0.012);
                obj.position.y = -1.75;
                obj.rotation.y = Math.PI;
                mixer = new THREE.AnimationMixer(obj);
                if(obj.animations.length>0) mixer.clipAction(obj.animations[0]).play();
                player.add(obj);

                fbx.load('gun.fbx', (g) => {
                    gun = g;
                    gun.scale.set(CONFIG.gunScale, CONFIG.gunScale, CONFIG.gunScale);
                    gun.rotation.set(CONFIG.gunRot.x, CONFIG.gunRot.y, CONFIG.gunRot.z);
                    gun.position.set(CONFIG.gunOffset.x, CONFIG.gunOffset.y, CONFIG.gunOffset.z);
                    player.add(gun);
                    
                    const flashGeo = new THREE.PlaneGeometry(0.8, 0.8);
                    const flashMat = new THREE.MeshBasicMaterial({color: 0xffaa00, side: THREE.DoubleSide});
                    muzzleFlash = new THREE.Mesh(flashGeo, flashMat);
                    muzzleFlash.position.set(0, 0, 80);
                    muzzleFlash.rotation.y = Math.PI/2;
                    muzzleFlash.visible = false;
                    gun.add(muzzleFlash);

                    txt.innerText = "Loading Enemies...";
                    // LOAD PNG INSTEAD OF TGA
                    texLoader.load('enemy_color.png', (tex) => {
                        fbx.load('enemy.fbx', (eModel) => {
                            txt.innerText = "READY!";
                            eModel.traverse(c => { if(c.isMesh) c.material = new THREE.MeshStandardMaterial({map: tex}); });
                            enemyTemplate = eModel;
                            spawnEnemies();
                        });
                    }, () => {
                        txt.innerText = "Skin Failed (No Spawn)";
                    });
                });
            });
        }

        function spawnEnemies() {
            if(!enemyTemplate) return;
            for(let i=0; i<CONFIG.totalEnemies; i++) {
                let e = enemyTemplate.clone();
                e.scale.set(0.012, 0.012, 0.012);
                e.rotation.x = -Math.PI/2;
                
                let x = (Math.random()-0.5)*300;
                let z = (Math.random()-0.5)*300;
                if(Math.abs(x)<50) x+=60;
                if(Math.abs(z)<50) z+=60;

                e.position.set(x, 0, z);
                e.userData.hp = 3;
                scene.add(e);
                enemies.push(e);

                const dot = document.createElement('div');
                dot.className = 'map-dot enemy-dot';
                document.getElementById('minimap').appendChild(dot);
                e.userData.dot = dot;
            }
        }

        function resetGame() {
            enemies.forEach(e => { scene.remove(e); if(e.userData.dot) e.userData.dot.remove(); });
            enemies = [];
            kills = 0; health = 100; ammo = 150;
            gameActive = true;
            
            document.getElementById('victory-screen').style.display = 'none';
            document.getElementById('death-screen').style.display = 'none';
            document.getElementById('hud-kills').innerText = `KILLS: 0 / ${CONFIG.totalEnemies}`;
            document.getElementById('hud-health').innerText = `HP: 100`;
            document.getElementById('hud-health').style.color = "#33ff33";
            document.getElementById('hud-ammo').innerText = `150`;
            
            spawnEnemies();
            if(vicMusic.isPlaying) vicMusic.stop();
            if(bgm.buffer && !bgm.isPlaying) bgm.play();
            controls.lock();
        }

        function checkDamage() {
            if(clock.getElapsedTime() - lastDamageTime < CONFIG.damageCooldown) return;
            for(let e of enemies) {
                if(player.position.distanceTo(e.position) < CONFIG.attackRange) {
                    health -= CONFIG.damage;
                    document.getElementById('hud-health').innerText = `HP: ${health}`;
                    document.getElementById('hud-health').style.color = "red";
                    lastDamageTime = clock.getElapsedTime();
                    if(health <= 0) {
                        gameActive = false;
                        document.getElementById('death-screen').style.display = 'block';
                        controls.unlock();
                    }
                    return;
                }
            }
        }

        function heal() {
            if(health >= 100) return;
            health = 100;
            const msg = document.getElementById('heal-msg');
            msg.style.display = 'block';
            document.getElementById('hud-health').innerText = `HP: 100`;
            document.getElementById('hud-health').style.color = "#0f0";
            setTimeout(() => { msg.style.display='none'; }, 1000);
        }

        function setupInputs() {
            controls = new PointerLockControls(camera, document.body);
            document.getElementById('start-btn').addEventListener('click', () => {
                controls.lock();
                document.getElementById('menu').style.display='none';
                gameActive = true;
                if(listener.context.state === 'suspended') listener.context.resume();
                if(bgm.buffer) bgm.play();
            });

            document.addEventListener('keydown', (e) => {
                if(e.code=='KeyW' || e.code=='ArrowUp') move.fwd = 1; 
                if(e.code=='KeyS' || e.code=='ArrowDown') move.fwd = -1;
                if(e.code=='KeyA' || e.code=='ArrowLeft') move.right = -1; 
                if(e.code=='KeyD' || e.code=='ArrowRight') move.right = 1;
                if(e.code=='KeyR') reload();
                if(e.code=='KeyH') heal();
            });
            document.addEventListener('keyup', (e) => {
                if(e.code=='KeyW'||e.code=='KeyS'||e.code=='ArrowUp'||e.code=='ArrowDown') move.fwd = 0;
                if(e.code=='KeyA'||e.code=='KeyD'||e.code=='ArrowLeft'||e.code=='ArrowRight') move.right = 0;
            });
            document.addEventListener('mousedown', (e) => {
                if(e.target.id === 'sound-toggle') return;
                if(e.button==0) isFiring = true;
                if(e.button==2) toggleScope(true);
            });
            document.addEventListener('mouseup', (e) => {
                if(e.button==0) isFiring = false;
                if(e.button==2) toggleScope(false);
            });

            // Android Controls
            const joyZone = document.getElementById('joystick-zone');
            const stick = document.getElementById('joystick-stick');
            let jStartX=0, jStartY=0;
            joyZone.addEventListener('touchstart', (e) => { jStartX = e.touches[0].clientX; jStartY = e.touches[0].clientY; });
            joyZone.addEventListener('touchmove', (e) => {
                const dx = e.touches[0].clientX - jStartX;
                const dy = e.touches[0].clientY - jStartY;
                const max = 40;
                const dist = Math.sqrt(dx*dx+dy*dy);
                const clamped = Math.min(dist, max);
                const ang = Math.atan2(dy, dx);
                const fx = Math.cos(ang) * clamped;
                const fy = Math.sin(ang) * clamped;
                stick.style.transform = `translate(calc(-50% + ${fx}px), calc(-50% + ${fy}px))`;
                move.right = fx/max; move.fwd = -(fy/max);
            });
            joyZone.addEventListener('touchend', () => { stick.style.transform = `translate(-50%, -50%)`; move.fwd=0; move.right=0; });

            document.getElementById('btn-shoot').addEventListener('touchstart', (e)=>{e.preventDefault(); isFiring=true;});
            document.getElementById('btn-shoot').addEventListener('touchend', (e)=>{e.preventDefault(); isFiring=false;});
            document.getElementById('btn-scope').addEventListener('touchstart', (e)=>{e.preventDefault(); toggleScope(!isScoped);});
            
            // NEW MOBILE BUTTONS
            document.getElementById('btn-reload').addEventListener('touchstart', (e)=>{e.preventDefault(); reload();});
            document.getElementById('btn-heal').addEventListener('touchstart', (e)=>{e.preventDefault(); heal();});

            let touchX=0;
            document.addEventListener('touchstart', (e)=> { if(e.touches[0].clientX > window.innerWidth/2) touchX = e.touches[0].clientX; });
            document.addEventListener('touchmove', (e)=> {
                if(e.touches[0].clientX > window.innerWidth/2 && !isScoped) {
                    player.rotation.y -= (e.touches[0].clientX - touchX) * 0.005;
                    touchX = e.touches[0].clientX;
                }
            });
        }

        function toggleScope(state) {
            isScoped = state;
            document.getElementById('scope-overlay').style.display = isScoped ? 'block' : 'none';
            document.getElementById('crosshair').style.display = isScoped ? 'none' : 'block';
            if(gun) gun.visible = !isScoped;
        }

        function fire() {
            if(ammo<=0 || isReloading) return;
            ammo--;
            document.getElementById('hud-ammo').innerText = ammo;
            
            if(sfxShoot.buffer && !sfxShoot.isPlaying) { sfxShoot.stop(); sfxShoot.play(); }

            if(muzzleFlash) {
                muzzleFlash.visible = true;
                muzzleFlash.rotation.z = Math.random() * Math.PI;
                setTimeout(() => muzzleFlash.visible = false, 50);
            }

            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(enemies, true);

            if(hits.length > 0) {
                let obj = hits[0].object;
                while(obj.parent && obj.parent !== scene) obj = obj.parent;
                
                if(sfxHit.buffer) { sfxHit.stop(); sfxHit.play(); }
                
                obj.userData.hp -= 1;
                if(obj.userData.hp <= 0) {
                    scene.remove(obj);
                    if(obj.userData.dot) obj.userData.dot.remove();
                    enemies = enemies.filter(e => e!==obj);
                    kills++;
                    document.getElementById('hud-kills').innerText = `KILLS: ${kills} / ${CONFIG.totalEnemies}`;
                    if(kills >= CONFIG.totalEnemies) {
                        gameActive = false;
                        document.getElementById('victory-screen').style.display = 'block';
                        controls.unlock();
                        if(bgm.isPlaying) bgm.stop();
                        if(vicMusic.buffer) vicMusic.play();
                    }
                }
            }
        }

        function reload() {
            if(isReloading || ammo==150) return;
            isReloading = true;
            document.getElementById('reload-msg').style.display = 'block';
            if(gun) gun.rotation.x -= 0.5;
            setTimeout(() => {
                ammo = 150;
                document.getElementById('hud-ammo').innerText = ammo;
                isReloading = false;
                document.getElementById('reload-msg').style.display = 'none';
                if(gun) gun.rotation.x += 0.5;
            }, 1500);
        }

        function updateMinimap() {
            const arrow = document.getElementById('player-arrow');
            arrow.style.transform = `translate(-50%, -50%) rotate(${-player.rotation.y}rad)`;

            enemies.forEach(e => {
                if(e.userData.dot) {
                    const relX = (e.position.x - player.position.x) / CONFIG.mapScale;
                    const relZ = (e.position.z - player.position.z) / CONFIG.mapScale;
                    let mapX = 75 + relX;
                    let mapY = 75 + relZ;
                    if(mapX < 5) mapX = 5; if(mapX > 145) mapX = 145;
                    if(mapY < 5) mapY = 5; if(mapY > 145) mapY = 145;
                    e.userData.dot.style.left = mapX + 'px';
                    e.userData.dot.style.top = mapY + 'px';
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!gameActive) { renderer.render(scene, camera); return; }

            const dt = clock.getDelta();
            if(mixer) mixer.update(dt);

            if(isFiring && clock.getElapsedTime() - lastShot > CONFIG.fireRate) {
                fire();
                lastShot = clock.getElapsedTime();
            }

            if(controls.isLocked) {
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                const yaw = Math.atan2(camDir.x, camDir.z);
                player.rotation.y = yaw + Math.PI;
            }

            const dist = CONFIG.speed * dt;
            player.translateZ(-move.fwd * dist);
            player.translateX(move.right * dist);

            const targetPos = player.position.clone();
            targetPos.y += CONFIG.camHeight;
            const backDir = new THREE.Vector3();
            camera.getWorldDirection(backDir);
            backDir.negate();
            backDir.multiplyScalar(isScoped ? 2.0 : CONFIG.camDist);
            camera.position.copy(targetPos).add(backDir);

            camera.fov = THREE.MathUtils.lerp(camera.fov, isScoped ? 15 : 70, 0.2);
            camera.updateProjectionMatrix();
            
            updateMinimap();
            checkDamage();

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>